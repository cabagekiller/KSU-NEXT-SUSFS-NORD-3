name: Android Kernel CI

on:
  workflow_dispatch:
    inputs:
      KSUNEXT_ENABLED:
        description: 'Enable KernelSU Next integration'
        required: false
        default: false
        type: boolean
      SUSFS_ENABLED:
        description: 'Enable SUSFS integration'
        required: false
        default: false
        type: boolean
      ANDROID_VERSION:
        description: 'Android version (e.g., 13, 14)'
        required: false
        default: 'android13'
        type: string
      KERNEL_VERSION:
        description: 'Kernel version (e.g., 5.10, 5.15)'
        required: false
        default: '5.10'
        type: string

env:
  TOOLCHAIN_VERSION: "aarch64-linux-android-4.9"
  DEFCONFIG: "oneplus/mt6983_v_15.0.0_nord_3_defconfig"
  MAKE_FLAGS: "-j$(nproc --all)"
  ARTIFACT_NAME: "kernel-$(date +'%Y%m%d-%H%M%S')"
  KERNEL_REPO: "https://github.com/OnePlusOSS/android_kernel_5.10_oneplus_mt6983.git"
  KERNEL_BRANCH: "oneplus/mt6983_v_15.0.0_nord_3"

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 150
    
    steps:
    - name: Configure Git to use symlinks
      run: | 
         git config --global core.symlinks true
         git config --global protocol.file.allow always
    - uses: actions/checkout@v4
      with:
        sparse-checkout: none  # This preserves symlinks
        fetch-depth: 0
      
    - name: Set up build environment
      run: |
        sudo apt-get update -qq
        sudo apt-get install -y --no-install-recommends \
          git-core gnupg flex bison build-essential zip curl zlib1g-dev \
          gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev \
          x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev \
          libxml2-utils xsltproc unzip fontconfig python3 bc cpio rsync \
          ccache libssl-dev patch

    - name: Clone kernel source
      run: |
        git clone --depth=1 \
          --branch ${{ env.KERNEL_BRANCH }} \
          ${{ env.KERNEL_REPO }} \
          kernel_source
    
    - name: Clone and merge OnePlus modules
      run: |
        # Clone modules to temp dir
        git clone --depth=1 \
          https://github.com/OnePlusOSS/android_kernel_modules_oneplus_mt6983.git \
          -b oneplus/mt6983_v_15.0.0_nord_3 \
          tmp_modules
    
        # Move contents selectively (excluding .git and handling conflicts)
        cd tmp_modules
        find . -maxdepth 1 ! -name .git ! -name . -exec sh -c '
          for item do
            if [ -e "../kernel_source/${item}" ]; then
              if [ -d "${item}" ]; then
                # Merge directories
                cp -r "${item}/"* "../kernel_source/${item}/"
              else
                # Overwrite files
                cp -f "${item}" "../kernel_source/${item}"
              fi
            else
              # Move new items
              mv "${item}" "../kernel_source/"
            fi
          done
        ' sh {} +
        cd ..
        rm -rf tmp_modules
        cd kernel_source
        ls -a
    - name: Debug merged vendor structure
      run: |
        echo "--- Listing kernel_source root after merge ---"
        ls -la /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || echo "kernel_source not found"
        echo "--- Listing kernel_source/vendor structure after merge (recursive) ---"
        ls -lR /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor || echo "kernel_source/vendor not found"
        echo "--- Specifically checking for vendor/oplus/sensor ---"
        ls -ld /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/sensor || echo "kernel_source/vendor/oplus/sensor not found"
        echo "--- Specifically checking for sensorhub path ---"
        ls -ld /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_devinfo || echo "Specific sensorhub path in kernel_source/vendor NOT found"
      shell: bash

    - name: Repair kernel source symlinks
      working-directory: kernel_source
      run: |
        # Find all broken symlinks and recreate them
        find . -type l ! -exec test -e {} \; -print | while read -r broken_symlink; do
          target=$(readlink "$broken_symlink")
          # Optional: Add a check here if the target *actually* exists now
          # if [ -e "$(dirname "$broken_symlink")/$target" ]; then # Basic relative path check
              echo "Fixing $broken_symlink -> $target"
              rm "$broken_symlink"
              ln -s "$target" "$broken_symlink"
          # else
          #    echo "Skipping $broken_symlink -> $target (Target still missing)"
          # fi
        done
    - name: Fix kernel/oplus_cpu (replace file with symlink)
      run: |
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1
        # Define the link path (relative to current dir: kernel_source)
        LINK_PATH="kernel/oplus_cpu"
        # --- CORRECTED ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/kernel/)
        # Path goes up one level to kernel_source, then down into vendor/oplus/kernel/cpu
        TARGET_PATH="../vendor/oplus/kernel/cpu"

        # --- CORRECTED ---
        # Define the absolute path to the target directory INSIDE kernel_source for verification
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel/cpu"

        echo "--- Checking state before fix ---"
        ls -ld "$LINK_PATH" || echo "$LINK_PATH does not exist"

        # Verify the target directory exists AT THE CORRECT EXPECTED LOCATION (inside kernel_source/vendor)
        if [ ! -d "$ABS_TARGET_DIR" ]; then
            echo "ERROR: Target directory $ABS_TARGET_DIR (inside kernel_source/vendor) does not exist!"
            echo "Check 'Clone and merge OnePlus modules' step and the modules repo structure."
            echo "--- Listing contents of kernel_source ---"
            ls -la "/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source"
            echo "--- Listing contents of kernel_source/vendor ---"
            ls -la "/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor" || echo "kernel_source/vendor not found"
            exit 1
        fi

        # Verify the required Kconfig file exists in the target AT THE CORRECT EXPECTED LOCATION
        if [ ! -f "$ABS_TARGET_DIR/sched/Kconfig" ]; then
            echo "ERROR: Required file $ABS_TARGET_DIR/sched/Kconfig not found!"
            echo "Check source checkout or branch in modules repo."
            exit 1
        fi

        # Ensure kernel directory exists (where the link will be placed)
        mkdir -p kernel

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing INSIDE kernel_source/vendor/...
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -sf "$TARGET_PATH" "$LINK_PATH"

        echo "--- Checking state after fix ---"
        ls -ld "$LINK_PATH"
        echo "--- Verifying link target contains sched/Kconfig ---"
        # This uses the link, which should now point correctly
        ls -l "$LINK_PATH/sched/Kconfig" || echo "ERROR: Could not find Kconfig via new link!"

      shell: bash
    - name: Fix kernel/locking/oplus_locking symlink (targeting synchronize)
      run: |
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path (relative to current dir: kernel_source)
        LINK_PATH="kernel/locking/oplus_locking"

        # --- CORRECTED TARGET based on file content ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/kernel/locking/)
        # Path goes up two levels to kernel_source, then down into vendor/oplus/kernel/synchronize
        TARGET_PATH="../../vendor/oplus/kernel/synchronize"

        # --- CORRECTED TARGET based on file content ---
        # Define the absolute path to the target directory INSIDE kernel_source/vendor for verification
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel/synchronize"

        echo "--- Checking state before fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH" || echo "$LINK_PATH does not exist"
        if [ -f "$LINK_PATH" ] && [ ! -L "$LINK_PATH" ]; then
           echo "WARNING: $LINK_PATH is a regular file. Content:"
           cat "$LINK_PATH"
        fi

        # Verify the target directory exists AT THE CORRECT EXPECTED LOCATION (synchronize)
        if [ ! -d "$ABS_TARGET_DIR" ]; then
            echo "ERROR: Target directory $ABS_TARGET_DIR (synchronize) does not exist!"
            echo "Check 'Clone and merge OnePlus modules' step and the modules repo structure."
            echo "--- Listing contents of kernel_source/vendor/oplus/kernel ---"
            ls -la "/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel" || echo "kernel_source/vendor/oplus/kernel not found"
            exit 1
        fi

        # Verify the required Kconfig file exists in the target (synchronize)
        # Check specifically for Kconfig inside the synchronize directory
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then
            echo "ERROR: Required file $ABS_TARGET_DIR/Kconfig not found!"
            echo "Check source checkout or branch in modules repo."
            exit 1
        fi

        # Ensure parent directory for link exists (kernel/locking)
        mkdir -p kernel/locking

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing to the synchronize directory
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -sf "$TARGET_PATH" "$LINK_PATH"

        echo "--- Checking state after fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH"
        echo "--- Verifying link target contains Kconfig ---"
        # This uses the link, which should now point correctly to the Kconfig in the synchronize dir
        ls -l "$LINK_PATH/Kconfig" || echo "ERROR: Could not find Kconfig via new link!"

      shell: bash
    - name: Fix mm/oplus_mm symlink (targeting vendor mm dir)
      run: |
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path (relative to current dir: kernel_source)
        LINK_PATH="mm/oplus_mm"

        # --- CORRECTED TARGET based on file content ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/mm/)
        # Path goes up one level to kernel_source, then down into vendor/oplus/kernel/mm
        TARGET_PATH="../vendor/oplus/kernel/mm"

        # --- CORRECTED TARGET based on file content ---
        # Define the absolute path to the target directory INSIDE kernel_source/vendor for verification
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel/mm"

        echo "--- Checking state before fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH" || echo "$LINK_PATH does not exist"
        if [ -f "$LINK_PATH" ] && [ ! -L "$LINK_PATH" ]; then
           echo "WARNING: $LINK_PATH is a regular file. Content:"
           cat "$LINK_PATH"
        fi

        # Verify the target directory exists AT THE CORRECT EXPECTED LOCATION (vendor mm)
        if [ ! -d "$ABS_TARGET_DIR" ]; then
            echo "ERROR: Target directory $ABS_TARGET_DIR (vendor mm) does not exist!"
            echo "Check 'Clone and merge OnePlus modules' step and the modules repo structure."
            echo "--- Listing contents of kernel_source/vendor/oplus/kernel ---"
            ls -la "/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel" || echo "kernel_source/vendor/oplus/kernel not found"
            exit 1
        fi

        # Verify the required Kconfig file exists in the target (vendor mm)
        # Check specifically for Kconfig inside the vendor mm directory
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then
            echo "ERROR: Required file $ABS_TARGET_DIR/Kconfig not found!"
            echo "Check source checkout or branch in modules repo."
            exit 1
        fi

        # Ensure parent directory for link exists (mm)
        mkdir -p mm

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing to the vendor mm directory
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -sf "$TARGET_PATH" "$LINK_PATH"

        echo "--- Checking state after fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH"
        echo "--- Verifying link target contains Kconfig ---"
        # This uses the link, which should now point correctly to the Kconfig in the vendor mm dir
        ls -l "$LINK_PATH/Kconfig" || echo "ERROR: Could not find Kconfig via new link!"

      shell: bash
    - name: Fix drivers/base/kernelFwUpdate symlink (targeting touchpanel)
      run: |
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path (relative to current dir: kernel_source)
        LINK_PATH="drivers/base/kernelFwUpdate"

        # --- CORRECTED TARGET based on file content ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/drivers/base/)
        # Path goes up two levels to kernel_source, then down into vendor/oplus/kernel/touchpanel/kernelFwUpdate
        TARGET_PATH="../../vendor/oplus/kernel/touchpanel/kernelFwUpdate"

        # --- CORRECTED TARGET based on file content ---
        # Define the absolute path to the target directory INSIDE kernel_source/vendor for verification
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel/touchpanel/kernelFwUpdate"

        echo "--- Checking state before fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH" || echo "$LINK_PATH does not exist"
        # Add check in case it's a file containing the path
        if [ -f "$LINK_PATH" ] && [ ! -L "$LINK_PATH" ]; then
           echo "WARNING: $LINK_PATH is a regular file. Content:"
           cat "$LINK_PATH"
        fi

        # Verify the target directory exists AT THE CORRECT EXPECTED LOCATION
        if [ ! -d "$ABS_TARGET_DIR" ]; then
            echo "ERROR: Target directory $ABS_TARGET_DIR (touchpanel) does not exist!"
            echo "Check 'Clone and merge OnePlus modules' step and the modules repo structure."
            echo "--- Listing contents of kernel_source/vendor/oplus/kernel/touchpanel ---"
            ls -la "/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel/touchpanel" || echo "kernel_source/vendor/oplus/kernel/touchpanel not found"
            exit 1
        fi

        # Verify the required Kconfig file exists in the target
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then
            echo "ERROR: Required file $ABS_TARGET_DIR/Kconfig not found!"
            echo "Check source checkout or branch in modules repo."
            exit 1
        fi

        # Ensure parent directory for link exists (drivers/base)
        mkdir -p drivers/base

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing to the vendor touchpanel directory
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -sf "$TARGET_PATH" "$LINK_PATH"

        echo "--- Checking state after fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH"
        echo "--- Verifying link target contains Kconfig ---"
        # This uses the link, which should now point correctly
        ls -l "$LINK_PATH/Kconfig" || echo "ERROR: Could not find Kconfig via new link!"

      shell: bash

    - name: Fix drivers/.../oplus_sensor_devinfo symlink (CORRECTED TARGET)
      run: |
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path (relative to current dir: kernel_source)
        LINK_PATH="drivers/misc/mediatek/sensor/2.0/oplus_sensor_devinfo"

        # --- CORRECTED TARGET based on ls -lR evidence ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/drivers/misc/mediatek/sensor/2.0/)
        # Path goes up 5 levels to kernel_source, then down into vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_devinfo
        TARGET_PATH="../../../../../vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_devinfo"

        # --- CORRECTED TARGET based on ls -lR evidence ---
        # Define the absolute path to the target directory INSIDE kernel_source/vendor for verification
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_devinfo"

        echo "--- Checking state before fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH" || echo "$LINK_PATH does not exist"

        # Verify the target directory exists AT THE CORRECT ACTUAL LOCATION
        if [ ! -d "$ABS_TARGET_DIR" ]; then
            echo "ERROR: Target directory $ABS_TARGET_DIR (actual location) does not exist!"
            echo "This should not happen if the ls -lR was correct. Check merge step again."
            exit 1
        fi

        # Verify the required Kconfig file exists in the target
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then
            echo "ERROR: Required file $ABS_TARGET_DIR/Kconfig not found!"
            exit 1
        fi

        # Ensure parent directory for link exists
        mkdir -p "$(dirname "$LINK_PATH")" # Use dirname for robustness

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing to the ACTUAL location
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -sf "$TARGET_PATH" "$LINK_PATH"

        echo "--- Checking state after fix for $LINK_PATH ---"
        ls -ld "$LINK_PATH"
        echo "--- Verifying link target contains Kconfig ---"
        # This uses the link, which should now point correctly
        ls -l "$LINK_PATH/Kconfig" || echo "ERROR: Could not find Kconfig via new link!"

      shell: bash
    - name: Fix drivers/.../oplus_sensor_feedback symlink (CORRECTED TARGET INSIDE)
      run: |
        echo "++++ STARTING feedback fix (Corrected Target INSIDE) ++++"
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path
        LINK_PATH="drivers/misc/mediatek/sensor/2.0/oplus_sensor_feedback"

        # --- CORRECTED TARGET PATH ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/drivers/misc/mediatek/sensor/2.0/)
        # Path goes up 5 levels to kernel_source, then down into vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_feedback
        TARGET_PATH="../../../../../vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_feedback"

        # --- CORRECTED TARGET PATH ---
        # Define the absolute path to the target directory INSIDE kernel_source/vendor for verification
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/sensor/kernel/sensorhub/oplus_sensor_feedback"

        echo "Verifying ABS target BEFORE link: $ABS_TARGET_DIR"
        if [ ! -d "$ABS_TARGET_DIR" ]; then echo "ERROR: ABS Target Dir MISSING before link! Check merge step."; exit 1; fi
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then echo "ERROR: Kconfig MISSING in ABS Target Dir before link! Check merge step."; exit 1; fi
        echo "ABS Target and Kconfig verified at [$ABS_TARGET_DIR]."

        # Ensure parent directory for link exists
        mkdir -p "$(dirname "$LINK_PATH")"

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing INSIDE kernel_source/vendor
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -svf "$TARGET_PATH" "$LINK_PATH"
        LN_EXIT_CODE=$?
        echo "ln exit code: $LN_EXIT_CODE"
        if [ $LN_EXIT_CODE -ne 0 ]; then echo "ERROR: ln command failed!"; exit 1; fi

        echo "--- Checking state immediately after link creation ---"
        ls -ld "$LINK_PATH"

        echo "--- Verifying link target access IMMEDIATELY after creation ---"
        echo "Attempting: ls -l '$LINK_PATH/Kconfig'"
        ls -l "$LINK_PATH/Kconfig"
        LS_EXIT_CODE=$?
        echo "ls via link exit code: $LS_EXIT_CODE"
        if [ $LS_EXIT_CODE -ne 0 ]; then
           echo "ERROR: Immediate ls via link failed!"
           exit 1 # Exit if verification fails
        else
           echo "Immediate ls via link SUCCEEDED."
        fi
        echo "++++ FINISHED feedback fix ++++"

      shell: bash
    - name: Fix drivers/.../oplus_consumer_ir symlink (CORRECTED TARGET INSIDE)
      run: |
        echo "++++ STARTING consumer_ir fix (Corrected Target INSIDE) ++++"
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path
        LINK_PATH="drivers/misc/mediatek/sensor/2.0/oplus_consumer_ir"

        # --- CORRECTED TARGET PATH ---
        # Define the target path RELATIVE TO THE LINK'S LOCATION (kernel_source/drivers/misc/mediatek/sensor/2.0/)
        # Path goes up 5 levels to kernel_source, then down into vendor/oplus/sensor/kernel/oplus_consumer_ir
        TARGET_PATH="../../../../../vendor/oplus/sensor/kernel/oplus_consumer_ir"

        # --- Define ABSOLUTE TARGET PATH for verification ---
        # Points INSIDE kernel_source/vendor/... where merge likely placed it
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/sensor/kernel/oplus_consumer_ir"

        echo "Verifying ABS target BEFORE link: $ABS_TARGET_DIR"
        # Add check in case placeholder file exists and points elsewhere
        if [ -f "$LINK_PATH" ] && [ ! -L "$LINK_PATH" ]; then
           echo "WARNING: Placeholder file exists at $LINK_PATH. Content:"
           cat "$LINK_PATH"
           echo "NOTE: Ignoring placeholder content and targeting INSIDE kernel_source based on verification."
        fi

        if [ ! -d "$ABS_TARGET_DIR" ]; then echo "ERROR: ABS Target Dir [$ABS_TARGET_DIR] MISSING before link! Check merge step."; exit 1; fi
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then echo "ERROR: Kconfig MISSING in ABS Target Dir [$ABS_TARGET_DIR] before link! Check merge step."; exit 1; fi
        echo "ABS Target and Kconfig verified at [$ABS_TARGET_DIR]."

        # Ensure parent directory for link exists
        mkdir -p "$(dirname "$LINK_PATH")"

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing INSIDE kernel_source/vendor
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -svf "$TARGET_PATH" "$LINK_PATH"
        LN_EXIT_CODE=$?
        echo "ln exit code: $LN_EXIT_CODE"
        if [ $LN_EXIT_CODE -ne 0 ]; then echo "ERROR: ln command failed!"; exit 1; fi

        echo "--- Checking state immediately after link creation ---"
        ls -ld "$LINK_PATH"

        echo "--- Verifying link target access IMMEDIATELY after creation ---"
        echo "Attempting: ls -l '$LINK_PATH/Kconfig'"
        ls -l "$LINK_PATH/Kconfig"
        LS_EXIT_CODE=$?
        echo "ls via link exit code: $LS_EXIT_CODE"
        if [ $LS_EXIT_CODE -ne 0 ]; then
           echo "ERROR: Immediate ls via link failed!"
           exit 1 # Exit if verification fails
        else
           echo "Immediate ls via link SUCCEEDED."
        fi
        echo "++++ FINISHED consumer_ir fix ++++"

      shell: bash
    - name: Fix drivers/.../oplus_touchscreen_v2 symlink (targeting touchpanel)
      run: |
        echo "++++ STARTING oplus_touchscreen_v2 fix (Targeting touchpanel) ++++"
        # Go into the main kernel source directory
        cd /home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source || exit 1

        # Define the link path
        LINK_PATH="drivers/input/touchscreen/oplus_touchscreen_v2"

        # --- Define TARGET PATH based on touchpanel pattern ---
        # Relative path from link location (drivers/input/touchscreen/) to target (vendor/oplus/kernel/touchpanel/)
        # Path goes up 3 levels to kernel_source, then down into vendor/oplus/kernel/touchpanel/oplus_touchscreen_v2
        TARGET_PATH="../../../vendor/oplus/kernel/touchpanel/oplus_touchscreen_v2"

        # --- Define ABSOLUTE TARGET PATH for verification ---
        # Points INSIDE kernel_source/vendor/... where merge likely placed it
        ABS_TARGET_DIR="/home/runner/work/KSU-NEXT-SUSFS-NORD-3/KSU-NEXT-SUSFS-NORD-3/kernel_source/vendor/oplus/kernel/touchpanel/oplus_touchscreen_v2"

        echo "Verifying ABS target BEFORE link: $ABS_TARGET_DIR"
        # Add check in case placeholder file exists and points elsewhere
        if [ -f "$LINK_PATH" ] && [ ! -L "$LINK_PATH" ]; then
           echo "WARNING: Placeholder file exists at $LINK_PATH. Content:"
           cat "$LINK_PATH"
           echo "Ensure TARGET_PATH and ABS_TARGET_DIR above match the intent of this file content."
        fi

        if [ ! -d "$ABS_TARGET_DIR" ]; then echo "ERROR: ABS Target Dir [$ABS_TARGET_DIR] MISSING before link! Check merge step and touchpanel path."; exit 1; fi
        if [ ! -f "$ABS_TARGET_DIR/Kconfig" ]; then echo "ERROR: Kconfig MISSING in ABS Target Dir [$ABS_TARGET_DIR] before link! Check merge step or modules repo."; exit 1; fi
        echo "ABS Target and Kconfig verified at [$ABS_TARGET_DIR]."

        # Ensure parent directory for link exists
        mkdir -p "$(dirname "$LINK_PATH")"

        # Remove the incorrect file/link/directory if it exists
        echo "Removing $LINK_PATH if it exists..."
        rm -rf "$LINK_PATH"

        # Create the correct symbolic link pointing INSIDE kernel_source/vendor
        echo "Creating symbolic link: $LINK_PATH -> $TARGET_PATH"
        ln -svf "$TARGET_PATH" "$LINK_PATH"
        LN_EXIT_CODE=$?
        echo "ln exit code: $LN_EXIT_CODE"
        if [ $LN_EXIT_CODE -ne 0 ]; then echo "ERROR: ln command failed!"; exit 1; fi

        echo "--- Checking state immediately after link creation ---"
        ls -ld "$LINK_PATH"

        echo "--- Verifying link target access IMMEDIATELY after creation ---"
        echo "Attempting: ls -l '$LINK_PATH/Kconfig'"
        ls -l "$LINK_PATH/Kconfig"
        LS_EXIT_CODE=$?
        echo "ls via link exit code: $LS_EXIT_CODE"
        if [ $LS_EXIT_CODE -ne 0 ]; then
           echo "ERROR: Immediate ls via link failed!"
           exit 1 # Exit if verification fails
        else
           echo "Immediate ls via link SUCCEEDED."
        fi
        echo "++++ FINISHED oplus_touchscreen_v2 fix ++++"

      shell: bash
    - name: Set up ccache
      uses: actions/cache@v3
      with:
        path: ~/.ccache
        key: ${{ runner.os }}-ccache-${{ env.TOOLCHAIN_VERSION }}-${{ hashFiles('kernel_source/**/Makefile') }}
        restore-keys: |
          ${{ runner.os }}-ccache-${{ env.TOOLCHAIN_VERSION }}-

    - name: Check for toolchain cache
      uses: actions/cache@v3
      id: toolchain-cache
      with:
        path: toolchain/${{ env.TOOLCHAIN_VERSION }}
        key: ${{ runner.os }}-toolchain-${{ env.TOOLCHAIN_VERSION }}-${{ hashFiles('kernel_source/**/Makefile') }}
        restore-keys: |
          ${{ runner.os }}-toolchain-${{ env.TOOLCHAIN_VERSION }}-
          
    - name: Download toolchain
      if: steps.toolchain-cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p toolchain
        cd toolchain
        # Use prebuilt toolchain from ARM instead
        wget https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
        tar xf gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz
        mv gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu aarch64-linux-android-4.9
        cd aarch64-linux-android-4.9
        # Verify compiler
        if [ -f "bin/aarch64-none-linux-gnu-gcc" ]; then
          echo "Compiler found at $(pwd)/bin/aarch64-none-linux-gnu-gcc"
          # Create symlinks for expected names
          ln -s aarch64-none-linux-gnu-gcc bin/aarch64-linux-android-gcc
          ln -s aarch64-none-linux-gnu-g++ bin/aarch64-linux-android-g++
        else
          echo "ERROR: Compiler not found!"
          find . -name "*gcc*"
          exit 1
        fi

    - name: Set up KernelSU Next
      if: ${{ inputs.KSUNEXT_ENABLED }}
      working-directory: kernel_source
      run: |
        curl -LSs "https://raw.githubusercontent.com/rifsxd/KernelSU-Next/next/kernel/setup.sh" | bash -s next-susfs-dev
        cd KernelSU-Next
        KSU_VERSION=$(expr $(git rev-list --count HEAD) "+" 10200)
        echo "KSUVER=$KSU_VERSION" >> $GITHUB_ENV
        sed -i "s/DKSU_VERSION=11998/DKSU_VERSION=${KSU_VERSION}/" kernel/Makefile
        cd ..

    - name: Set up SUSFS
      if: ${{ inputs.SUSFS_ENABLED }}
      working-directory: kernel_source
      run: |
        git config --global user.name "GitHub Actions Bot"
        git config --global user.email "actions@github.com"
        git clone https://gitlab.com/simonpunk/susfs4ksu.git -b gki-${{ github.event.inputs.ANDROID_VERSION }}-${{ github.event.inputs.KERNEL_VERSION }}
        git clone https://github.com/cabagekiller/kernel_patches.git
        #cp susfs4ksu/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch ./KernelSU-Next/
        cp susfs4ksu/kernel_patches/50_add_susfs_in_gki-${{ github.event.inputs.ANDROID_VERSION }}-${{ github.event.inputs.KERNEL_VERSION }}.patch ./
        #cp kernel_patches/KernelSU-Next-Implement-SUSFS-v1.5.5-Universal.patch ./KernelSU-Next/
        cp susfs4ksu/kernel_patches/fs/* ./fs/
        cp susfs4ksu/kernel_patches/include/linux/* ./include/linux/
        
        # Apply patches
        cd ./KernelSU-Next
        #patch -p1 < KernelSU-Next-Implement-SUSFS-v1.5.5-Universal.patch || true
        #patch -p1 --forward < 10_enable_susfs_for_ksu.patch || true
        cd ..
        patch -p1 < 50_add_susfs_in_gki-${{ github.event.inputs.ANDROID_VERSION }}-${{ github.event.inputs.KERNEL_VERSION }}.patch || true
        cp kernel_patches/69_hide_stuff.patch ./
        cp kernel_patches/next/syscall_hooks.patch ./
        patch -p1 -F 3 < 69_hide_stuff.patch || true
        patch -p1 -F 3 < syscall_hooks.patch || true
        git add -A && git commit -a -m "BUILD Kernel: Added SUSFS patches" || true
        git add -A && git commit -a -m "BUILD Kernel: SUSFS changes" || true

    - name: Configure Kernel Defconfig
      if: ${{ inputs.KSUNEXT_ENABLED || inputs.SUSFS_ENABLED }}
      working-directory: kernel_source
      run: |
        # Basic KernelSU and SUSFS configs
        echo "CONFIG_KSU=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SUS_PATH=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_TRY_UMOUNT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SPOOF_UNAME=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_ENABLE_LOG=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_OPEN_REDIRECT=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_SUSFS_SUS_SU=n" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_KSU_WITH_KPROBES=n" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_COMPAT=y" >> ./arch/arm64/configs/gki_defconfig
        # Add additional tmpfs config setting
        echo "CONFIG_TMPFS_XATTR=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_TMPFS_POSIX_ACL=y" >> ./arch/arm64/configs/gki_defconfig
        # Add additional tmpfs config setting
        echo "CONFIG_IP_NF_TARGET_TTL=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_IP6_NF_TARGET_HL=y" >> ./arch/arm64/configs/gki_defconfig
        echo "CONFIG_IP6_NF_MATCH_HL=y" >> ./arch/arm64/configs/gki_defconfig
        
        # Remove defconfig check if SUSFS is enabled
        if ${{ inputs.SUSFS_ENABLED }}; then
          sed -i '2s/check_defconfig//' ./build.config.gki || true
        fi


    - name: Set up build environment variables
      run: |
        echo "ARCH=arm64" >> $GITHUB_ENV
        echo "CROSS_COMPILE=$(pwd)/toolchain/${{ env.TOOLCHAIN_VERSION }}/bin/aarch64-none-linux-gnu-" >> $GITHUB_ENV
        echo "PATH=$(pwd)/toolchain/${{ env.TOOLCHAIN_VERSION }}/bin:$PATH" >> $GITHUB_ENV
        echo "CCACHE_DIR=$(pwd)/.ccache" >> $GITHUB_ENV
        echo "USE_CCACHE=1" >> $GITHUB_ENV
        echo "CCACHE_EXEC=/usr/bin/ccache" >> $GITHUB_ENV
        
        # Verify setup
        echo "Compiler path: $(pwd)/toolchain/${{ env.TOOLCHAIN_VERSION }}/bin/aarch64-none-linux-gnu-gcc"
        $(pwd)/toolchain/${{ env.TOOLCHAIN_VERSION }}/bin/aarch64-none-linux-gnu-gcc --version || (echo "Compiler test failed!" && exit 1)
        
    - name: Show environment info
      working-directory: kernel_source
      run: |
        echo "Toolchain path: $(pwd)/toolchain/${{ env.TOOLCHAIN_VERSION }}/bin"
        echo "CCACHE stats:"
        ccache -s
        if [ -n "$KSUVER" ]; then
          echo "KernelSU Next version: $KSUVER"
        fi
        if ${{ inputs.SUSFS_ENABLED }}; then
          echo "SUSFS enabled for Android ${{ github.event.inputs.ANDROID_VERSION }}, Kernel ${{ github.event.inputs.KERNEL_VERSION }}"
          echo "Modified defconfig with SUSFS settings"
        fi
    - name: Make defconfig
      working-directory: kernel_source
      run: |
        # Verify environment
        echo "Current PATH: $PATH"
        echo "CROSS_COMPILE: $CROSS_COMPILE"
        which aarch64-linux-android-gcc
        aarch64-linux-android-gcc --version
        
        # Create output directory and copy config
        mkdir -p out
        cp arch/arm64/configs/gki_defconfig out/.config
        
        # Apply any modifications
        if [ -n "$(grep 'CONFIG_KSU=y' out/.config)" ]; then
          echo "KernelSU config already present"
        else
          echo "Applying KernelSU config"
          echo "CONFIG_KSU=y" >> out/.config
        fi
        
        # Finalize config
        make O=out olddefconfig

    - name: Build kernel
      working-directory: kernel_source
      run: |
        make O=out ${{ env.MAKE_FLAGS }} 2>&1 | tee build.log
        

    - name: Prepare kernel image
      working-directory: kernel_source
      run: |
        mkdir -p kernel_output
        cp out/arch/arm64/boot/Image.gz-dtb kernel_output/Image.gz-dtb
        # Decompress if needed (some devices need uncompressed Image)
        gunzip -kf kernel_output/Image.gz-dtb || true
        mv kernel_output/Image.gz-dtb kernel_output/Image 2>/dev/null || true

    - name: Set up AnyKernel3
      run: |
        git clone https://github.com/TanakaLun/AnyKernel3 --depth=1
        rm -rf ./AnyKernel3/.git
        # Copy kernel image
        cp kernel_output/Image* ./AnyKernel3/
        # Add version info
        echo "kernel.string=KernelSU Next v${KSUVER} ${FEIL}" >> ./AnyKernel3/anykernel.sh
        echo "device.name1=OnePlus Nord 3" >> ./AnyKernel3/anykernel.sh
        # Modify anykernel.sh for our device
        sed -i 's/do.devicecheck=1/do.devicecheck=0/' ./AnyKernel3/anykernel.sh
        sed -i 's/do.modules=1/do.modules=0/' ./AnyKernel3/anykernel.sh

    - name: Package AnyKernel3 zip
      run: |
        cd AnyKernel3
        zip -r9 ../AnyKernel3_KernelSU_Next_${KSUVER}_${FEIL}.zip * -x .git*
        cd ..

    - name: Upload AnyKernel3 zip
      uses: actions/upload-artifact@v4
      with:
        name: AnyKernel3_KernelSU_Next_${{ env.KSUVER }}_${{ github.event.inputs.FEIL }}
        path: ./AnyKernel3_KernelSU_Next_*.zip

    - name: Archive build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: |
          out/arch/arm64/boot/Image.gz-dtb
          out/.config
          build.log
          kernel_output/*

    - name: Upload build log on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-failure-log
        path: build.log
